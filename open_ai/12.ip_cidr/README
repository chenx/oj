ip / cidr iterator
Q1 - 升序iterate 一个 ip address
Q2 - 降序iterate 一个 ip address
Q3 - iterate 一个cidr

IP address iterator. 第一問 forward 第二問 backward 第三問 forward/backward with CIDR

cidr就是个range，拿到cidr之后找base ip你就知道range的boundary了，这题主要看coding style把iterator写漂亮就行了， 
LC里面有个cidr的题是一样的概念，转number然后计算最后再转回ip就可以了

非常简单- 前面给你个ipv4，255.255.255.0这样的，现在给你个cidr 255.255.255.0/30 这样，一样的逻辑ip转成number然后在range里面iterate就行了


Forward (正向迭代) 要求实现一个 IPV4Iterator 类。 给定一个起始 IP 字符串（比如 "192.168.0.1"），需要让这个迭代器从该起点开始，
逐个返回 (yield) 后续所有的 IP 地址，直到达到 IPv4 的上限 255.255.255.255 为止。

代码接口要求： 需要实现标准的 Python 迭代器协议 (Iterator Protocol)，即 __init__, __iter__, 和 __next__。

Part 2: Reverse (反向迭代) 给定一个终点 IP（比如 "192.168.0.255"），实现一个倒序迭代器。要求从这个 IP 开始，反向遍历 (decrement) 直至 0.0.0.0。

Part 3: CIDR (网段解析)：这次的输入是一个 CIDR 格式的字符串（比如 "192.168.1.0/24"）。 你需要解析该字符串，
利用位运算 (Bitwise Operation) 算出该网段的 Start IP 和 End IP，然后遍历并返回该网段内包含的所有 IP 地址。

    CIDR 格式说明：IP地址/数字（例如 192.168.1.0/24）。

        斜杠前：基准 IP。

        斜杠后 (/n)：网络前缀长度。意思是该 IP 的 32 位二进制中，前 n 位固定，剩下的 32-n 位（主机位）是可变的。

核心考点是如何根据掩码位（Mask，即 /24）快速计算出网络区间的范围。

Part 4: Optimization 后续问：如何优化时间复杂度和空间复杂度

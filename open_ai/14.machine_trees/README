Tree of machines

给你一多叉树，每个节点是一个机器，并且知道自己父亲和孩子们的指针，并且只能跟自己的父亲或孩子们通过

    sendMessage(nodeId, string)

复制代码
通信（不用实现这个函数，当API即可）。
(1) 要求你实现一个函数

    receiveMessage(fromNodeId, string)

复制代码
，让所有节点找到自己后代的数量， 但只需要根节点打印 （父亲是null就是根节点）。
(2)  follow-up: 改

    receiveMessage

复制代码
， 让所有节点找到自己的树结构。但只需要根节点打印树结构。用任意方式表示树结构都行，比如你可以打印

    1(2,3(4))

复制代码
来表示跟节点是1，1有两个孩子2，3，3有一个孩子4.
(3) （口头讲）如果机器之间发送消息有重传或者失败的话，你要怎么处理

1) count machines in a tree
Design a method to count the total number of machines in a tree where each node represents a machine. 
Machines can only communicate with their parent and child nodes using a provided interface with sendAsyncMessage() 
and receiveMessage() functions. Implement the receiveMessage method to handle 'count' messages by sending the same 
message to child nodes and ‘response’ messages by recording the count numbers from each child, summing them up, and 
returning the sum to the parent node. Consider special cases such as when the node is a root or a leaf.

2) return a tree topology
Extend the feature from the previous question to not only count the machines but also return the entire tree's topology. 
Define two new message types, 'topology' and 'topologyResponse’, and ensure the response includes the actual data needed 
to be sent back. Implement the logic to handle these messages similarly to the 'count' and 'countResponse' messages 
from the first question.


电面 coding：是给定root node，sendAsyncMessage()和receiveMessage()方法，让统计cluster中node的数量。地里面经里出现过的题目了。
之后问了两个follow up，第一个问题是让返回cluster的结构而不是node的数量，第二个是问如果会message会fail，可能会有retry，怎么保证结果依然正确。
第一个follow up我是用类似TreeNode的方法记录node之间的关系，最后return root node。
第二个follow up是用set track已经访问过的节点，已经处理过的就不要再处理了。


class Node:
    def __init__(self, node_id: str, children: List[str], parent: str):
        self.node_id = node_id
        self.children = children if children else []
        self.parent = parent
        self.child_counts: Dict[str, int] = {}
        self.child_structures: Dict[str, str] = {}

    def receiveMessage(self, from_node_id: str, message: str):
        print(f"DEBUG: Node {self.node_id} received from {from_node_id}: '{message}'")

        if message == 'START_COUNT' and from_node_id is None:
            if not self.children:
                print(f"Final Result (Root {self.node_id}): Total nodes = 1")
            else:
                for child_id in self.children:
                    sendMessage(child_id, self.node_id, 'COUNT_REQUEST')
            return
        if message == 'COUNT_REQUEST' and from_node_id == self.parent:
            if not self.children:
                sendMessage(self.parent, self.node_id, 'COUNT_RESPONSE:1')
            else:
                for child_id in self.children:
                    sendMessage(child_id, self.node_id, 'COUNT_REQUEST')
            return
        if message.startswith('COUNT_RESPONSE:') and from_node_id in self.children:
            count = int(message.split(":")[1])
            self.child_counts[from_node_id] = count
            if len(self.child_counts) == len(self.children):
                total_count = 1 + sum(self.child_counts.values())
                if self.parent is None:
                    print(f"Final Result (Root {self.node_id}): Total nodes = {total_count}")
                else:
                    sendMessage(self.parent, self.node_id, f'COUNT_RESPONSE:{total_count}')
                self.child_counts.clear()
            return

        if message == 'START_STRUCTURE' and from_node_id is None:
            if not self.children:
                print(f"Final Result (Root {self.node_id}): Tree Structure = {self.node_id}")
            else:
                for child_id in self.children:
                    sendMessage(child_id, self.node_id, 'STRUCTURE_REQUEST')
            return

        if message == 'STRUCTURE_REQUEST' and from_node_id == self.parent:
            if not self.children:
                # 叶子节点的结构就是它自己
                sendMessage(self.parent, self.node_id, f'STRUCTURE_RESPONSE:{self.node_id}')
            else:
                for child_id in self.children:
                    sendMessage(child_id, self.node_id, 'STRUCTURE_REQUEST')
            return

        if message.startswith('STRUCTURE_RESPONSE:') and from_node_id in self.children:
            structure = message.split(':')[1]
            self.child_structures[from_node_id] = structure
            if len(self.child_structures) == len(self.children):
                sorted_child_ids = sorted(self.child_structures.keys())
                sub_structures = [self.child_structures[cid] for cid in sorted_child_ids]

                final_structures = f"{self.node_id}({','.join(sub_structures)})"
                if self.parent is None:
                    print(f"Final Result (Root {self.node_id}): Tree Structure = {final_structures}")
                else:
                    sendMessage(self.parent, self.node_id, f'STRUCTURE_RESPONSE:{final_structures}')
                self.child_structures.clear()
            Return
